üìï NORMA ‚Äî ARQUITETURA
Projeto SaaS KAIROS ‚Äî Vers√£o 1.0 (FECHADA)
________________________________________
0. OBJETIVO E ESCOPO
0.1 Objetivo
1.	Definir a arquitetura oficial do KAIROS para garantir:
1.1. modularidade por dom√≠nio (feature-driven)
1.2. dire√ß√£o de depend√™ncia consistente (Clean/Hex adaptada)
1.3. isolamento de regra de neg√≥cio (dom√≠nio puro)
1.4. baixo acoplamento entre features
1.5. base s√≥lida para testes e seguran√ßa (normas 0.2 e 0.3)
0.2 Escopo
2.	Esta norma regula:
2.1. estrutura de pastas
2.2. camadas internas por feature
2.3. fronteiras entre features
2.4. contratos (ports/public API)
2.5. composi√ß√£o/inje√ß√£o de depend√™ncias
2.6. regras de importa√ß√£o e acoplamento
________________________________________
1. PRINC√çPIOS ARQUITETURAIS (OBRIGAT√ìRIOS)
1.1 Arquitetura orientada a features ‚Äî REGRA MESTRA
3.	O KAIROS √© feature-driven: a unidade prim√°ria de organiza√ß√£o √© src/features/<feature>/.
4.	Regras de neg√≥cio pertencem a uma feature espec√≠fica, salvo infraestrutura transversal em src/core/.
1.2 Clean Architecture / Hexagonal (adaptada) ‚Äî DIRE√á√ÉO DE DEPEND√äNCIA
5.	Dire√ß√£o obrigat√≥ria:
5.1. UI ‚Üí Application ‚Üí Domain
5.2. Infra (adapters) ‚Üí Application (ports) e Domain (tipos)
6.	domain/ n√£o pode depender de:
6.1. UI
6.2. framework
6.3. banco de dados
6.4. SDKs externos
1.3 Plano derivado e execu√ß√£o factual (coer√™ncia estrutural)
7.	Artefatos derivados devem ser regener√°veis; logs factuais s√£o imut√°veis.
________________________________________
2. ESTRUTURA OFICIAL DE PASTAS (OBRIGAT√ìRIA)
8.	Estrutura macro obrigat√≥ria:
9.	src/app/
9.1. apenas rotas, p√°ginas, layouts e composi√ß√£o
9.2. proibido colocar regra de neg√≥cio cr√≠tica
10.	src/features/<feature>/
10.1. regra de neg√≥cio e UI espec√≠ficas do dom√≠nio da feature
10.2. feature N√ÉO pode virar pasta-dep√≥sito
11.	src/core/
11.1. infraestrutura transversal (auth, clients, config, policies globais)
11.2. composition root oficial (src/core/composition/)
11.3. contratos transversais quando necess√°rio
12.	src/shared/
12.1. utilit√°rios gen√©ricos e reuso sem dom√≠nio
13.	src/components/
13.1. UI transversal (layout/design system) sem regra de dom√≠nio
________________________________________
3. PADR√ÉO INTERNO DE FEATURE (OBRIGAT√ìRIO)
14.	Toda feature deve seguir:
src/features/<feature>/
  domain/
  application/
  infra/
  ui/
  index.ts
15.	Responsabilidades:
16.	domain/
16.1. entidades, value objects, invariantes, regras puras
16.2. sem IO (sem DB/rede/storage)
17.	application/
17.1. use-cases
17.2. ports (interfaces) para depend√™ncias externas
17.3. coordena√ß√£o de regras do dom√≠nio
18.	infra/
18.1. implementa√ß√µes concretas das ports (ex.: Supabase repos)
18.2. adapters e serializa√ß√£o
18.3. sem vazar implementa√ß√µes para fora da feature
19.	ui/
19.1. componentes e hooks da feature
19.2. valida√ß√µes de UX (n√£o regras cr√≠ticas)
19.3. chama use-cases, n√£o infra diretamente
20.	index.ts (Public API)
20.1. exporta apenas o que pode ser consumido fora da feature
20.2. deve ser a porta oficial para imports externos
________________________________________
4. FRONTEIRAS ENTRE FEATURES (BOUNDARIES)
21.	√â proibido uma feature importar implementa√ß√µes internas de outra feature.
22.	Comunica√ß√£o permitida entre features somente via:
22.1. exports do index.ts da feature alvo (public API)
22.2. contratos transversais em src/core quando estritamente necess√°rio
________________________________________
5. COMPOSI√á√ÉO E INJE√á√ÉO DE DEPEND√äNCIAS
5.1 Composition root oficial
23.	A composi√ß√£o de implementa√ß√µes concretas √© centralizada em:
‚Ä¢	src/core/composition/
24.	A UI e os use-cases n√£o podem instanciar clients de DB/SDK diretamente.
5.2 Regra de depend√™ncia de use-case
25.	Use-cases dependem de ports (interfaces) e recebem depend√™ncias por inje√ß√£o.
26.	Infra implementa as ports.
________________________________________
6. REGRAS DE IMPORTA√á√ÉO (ENFORCEMENT)
6.1 Deep imports
27.	Proibido deep import entre features:
‚Ä¢	proibido importar src/features/outra-feature/* fora do index.ts da outra feature
28.	Permitido deep import dentro da pr√≥pria feature (uso interno).
6.2 Import padr√£o recomendado
29.	Consumo externo de feature deve ser via:
‚Ä¢	import { X } from "@/features/<feature>" (via index.ts)
________________________________________
7. NOMENCLATURA E PADR√ïES
7.1 Nome de feature (padr√£o √∫nico)
30.	Features usam kebab-case:
‚Ä¢	daily-plan, subjects, profile, informatics, calendar
7.2 Conven√ß√µes
31.	Ports: I<Nome>Repository, I<Nome>Service
32.	Infra: Supabase<Nome>Repository, Http<Nome>Service
33.	Use-cases: createX, updateX, generateX, completeX
________________________________________
8. EVOLU√á√ÉO ARQUITETURAL (SEM OVERENGINEERING)
34.	CQRS n√£o √© obrigat√≥rio; √© permitido sob justificativa t√©cnica.
35.	Event-driven entre features n√£o √© obrigat√≥rio; eventos de dom√≠nio internos s√£o permitidos.
________________________________________
9. PROIBI√á√ïES ABSOLUTAS (ANTI-PADR√ïES)
36.	√â proibido:
36.1. l√≥gica de neg√≥cio cr√≠tica em React components
36.2. acesso direto ao DB a partir de UI
36.3. feature importar infra/ de outra feature
36.4. criar abstra√ß√µes sem necessidade (YAGNI arquitetural)
________________________________________
10. CHECKLIST DE CONFORMIDADE (ARQUITETURA)
37.	Antes de merge:
37.1. regra de neg√≥cio est√° na feature correta?
37.2. domain est√° puro?
37.3. application depende de ports?
37.4. infra implementa ports e n√£o vaza?
37.5. imports entre features passam pelo index.ts?
37.6. composi√ß√£o est√° em src/core/composition/?
________________________________________
11. STATUS NORMATIVO
38.	Norma obrigat√≥ria para todo desenvolvimento novo.
39.	Migra√ß√£o de legado: gradual, sem ‚Äújeitinho‚Äù, com governan√ßa.
